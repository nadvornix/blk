#!/bin/zsh
# macOS zsh interactive unblocker (sed-only, BSD-safe)
set -euo pipefail

# ---------- Platform & deps ----------
[[ "$OSTYPE" == darwin* ]] || { print -u2 "macOS required."; exit 1; }
[[ -n "${ZSH_VERSION-}" ]] || { print -u2 "Run under zsh."; exit 1; }
command -v gum >/dev/null 2>&1 || { print -u2 "brew install gum"; exit 1; }
command -v at  >/dev/null 2>&1 || { print -u2 "Install/enable 'at' (atrun)."; }

# ---------- Config ----------
HOSTS="/etc/hosts"
FOCUS_DIR="$HOME/.focus"
RECENTS_FILE="$FOCUS_DIR/recents"
LOG_FILE="$HOME/unblk.log"
RECENTS_MAX=3
MIN_MIN=1
MAX_MIN=480
BLK_PATH="/Users/jiri2/blk"   # adjust if needed

# ---------- Root & immutability ----------
if [[ "$EUID" -ne 0 ]]; then
  print -u2 "Use: sudo $0"
  exit 1
fi
mkdir -p "$FOCUS_DIR"
touch "$RECENTS_FILE" "$LOG_FILE"
sudo chflags nouchg "$HOSTS" 2>/dev/null || true

# Normalize /etc/hosts: uncomment all lines except those containing NEVERBLOCK
# This ensures the file is in a proper state, especially if manually edited
sudo sed -i '' '/NEVERBLOCK/!s/^#*//' "$HOSTS" || { print -u2 "Error: Failed to normalize $HOSTS"; exit 1; }

# ---------- Debug helper ----------
dbg() { [[ -n "${FOCUS_DEBUG-}" ]] && print -u2 "DEBUG: $*"; }

# ---------- Small utils ----------
trim_ws() { sed -E 's/^[[:space:]]+|[[:space:]]+$//g'; }
ere_escape(){ sed -E 's/[][\.^$*+?|(){}]/\\&/g'; }

is_valid_domain() {
  local d="$1"
  [[ "$d" == "localhost" ]] && return 0
  if [[ ${#d} -le 253 && "$d" =~ ^([a-zA-Z0-9-]{1,63}\.)+[a-zA-Z]{2,63}$ ]]; then
    IFS='.' read -A parts <<< "$d"
    for p in "${parts[@]}"; do
      [[ "$p" == -* || "$p" == *- ]] && return 1
    done
    return 0
  fi
  return 1
}

list_recents(){ head -n "$RECENTS_MAX" "$RECENTS_FILE" | awk 'NF'; }
update_recents(){
  local tmp; tmp="$(mktemp)"; cp "$RECENTS_FILE" "$tmp" 2>/dev/null || true
  for d in "$@"; do
    grep -Fxv "$d" "$tmp" > "$tmp.2" || true
    print -- "$d" | cat - "$tmp.2" | head -n "$RECENTS_MAX" > "$tmp"
    rm -f "$tmp.2"
  done
  mv "$tmp" "$RECENTS_FILE"
}

pick_duration(){
  local c d
  c=$(gum choose --header "Duration (minutes)" "10" "25" "60" "Custom") || { print -u2 "Duration required."; exit 1; }
  case "$c" in
    10|25|60) d="$c" ;;
    Custom)
      d=$(gum input --placeholder "Enter minutes ($MIN_MIN–$MAX_MIN)") || { print -u2 "Minutes required."; exit 1; }
      d="$(print -r -- "$d" | trim_ws)"
      [[ "$d" =~ ^[0-9]+$ ]] || { print -u2 "Invalid minutes."; exit 1; }
      (( d>=MIN_MIN && d<=MAX_MIN )) || { print -u2 "Minutes must be $MIN_MIN–$MAX_MIN."; exit 1; }
      ;;
    *) print -u2 "Invalid selection."; exit 1;;
  esac
  echo "$d"
}

require_reason_minlen(){
  local min="$1" prompt="${2:-Reason (min $1 chars)}" r=""
  while true; do
    r=$(gum input --placeholder "$prompt") || { print -u2 "Reason required."; exit 1; }
    r="$(print -r -- "$r" | trim_ws)"
    (( ${#r} >= min )) && { print -r -- "$r"; return 0; }
    gum style --foreground 196 "Reason must be at least $min characters."
  done
}

# Duration-scaled wait (Option A), with max tier capped to 30–90s for specific
scaled_wait_specific(){
  local d="$1" lo=0 hi=0
  if   (( d <= 20 ));   then lo=0;  hi=2
  elif (( d <= 60 ));   then lo=5;  hi=12
  elif (( d <= 180 ));  then lo=15; hi=45
  else                     lo=30; hi=90
  fi
  local span=$((hi - lo + 1)); local r=$(( RANDOM % span ))
  echo $(( lo + r ))
}

# --- Time gate & captcha helpers ---

is_before_10am() {
  # 0..9 -> true, 10..23 -> false
  local hh; hh="$(/bin/date +%H)"
  (( 10#${hh} < 10 ))
}

gen_token() {
  # $1 = length
  local n="${1:-20}"
  LC_ALL=C tr -dc 'A-Za-z0-9' </dev/urandom | head -c "$n"
}

require_all_captcha() {
  # one attempt; abort on mismatch
  local n="${1:-20}"
  local tok; tok="$(gen_token "$n")"
  # show nicely
  gum style --border normal --padding "1 2" --align center --bold --width 50 "$tok" >/dev/tty
  local typed
  typed="$(gum input --placeholder "Retype the string above exactly" </dev/tty)"
  if [[ "$typed" != "$tok" ]]; then
    gum style --foreground 196 "Captcha mismatch. Aborting." >/dev/tty
    return 1
  fi
  return 0
}


wait_random_secs(){ local s="$1"; (( s>0 )) && gum spin --title "Waiting ${s}s…" -- sleep "$s"; }
confirm_window_press_enter(){ local t="$1"; print "Press Enter within ${t}s to confirm…"; read -t "$t" -r _ || return 1; }

flush_dns(){ sudo dscacheutil -flushcache || true; sudo killall -HUP mDNSResponder 2>/dev/null || true; }
log_event(){ local ts; ts="$(date '+%Y-%m-%d %H:%M:%S')"; print -- "$ts; UNBLOCK; Duration: $1 minutes; Reason: $2${3:+; Specific: $3}" >> "$LOG_FILE"; }
schedule_reblock(){ local m="$1"; echo "sudo $BLK_PATH " | at now + "$m" minutes 2>/dev/null || true; }

# ---------- SED-based edits (BSD-safe, no braces) ----------

# SPECIFIC: for each domain, comment any non-comment line containing it,
# unless the line contains NEVERBLOCK.
comment_lines_containing_domains(){
  local d pat
  for d in "$@"; do
    pat="$(printf '%s' "$d" | ere_escape)"
    dbg "sed specific pattern: /$pat/"
    sudo sed -E -i '' \
      -e '/NEVERBLOCK/ b' \
      -e "/$pat/ !b" \
      -e '/^[[:space:]]*#/ b' \
      -e 's/^/# /' \
      "$HOSTS" || { print -u2 "Error: sed failed for domain: $d"; return 1; }
  done
}

# ALL: comment any un-commented 0.0.0.0/127.0.0.1 host line,
# unless the line contains NEVERBLOCK.
comment_all_block_lines(){
  dbg "sed ALL: comment lines with BLOCKME (skip NEVERBLOCK)"
  sudo sed -E -i '' \
    -e '/NEVERBLOCK/ b' \
    -e '/BLOCKME/ !b' \
    -e 's/^/# /' \
    "$HOSTS" || { print -u2 "Error: sed failed for ALL unblock"; return 1; }
}

# ---------- Interactive flow ----------
# 1. Ask for reason first (standardized length requirement)
REASON="$(require_reason_minlen 6 "Reason (min 6 chars)")"

# 2. Ask for duration
DUR="$(pick_duration)"

# 3. Ask for domains/ALL
initial=$(gum input --placeholder "What do you want to unblock? (ALL or space-separated domains) — leave empty to pick from Recents") || { print -u2 "Cancelled."; exit 1; }
initial="$(print -r -- "$initial" | trim_ws)"

is_all=0
typeset -a domains; domains=()

if [[ -z "$initial" ]]; then
  recs=("${(@f)$(list_recents)}")
  if (( ${#recs[@]} )); then
    sel=$(printf "%s\n%s\n" "⎆ Type domains manually…" "${recs[@]}" | gum choose --no-limit --header "Select domains (space toggles) or choose '⎆ Type domains manually…'") || { print -u2 "No selection."; exit 1; }
    if [[ "$sel" == "⎆ Type domains manually…" ]]; then
      manual=$(gum input --placeholder "Enter space-separated domains") || { print -u2 "No domains provided."; exit 1; }
      manual="$(print -r -- "$manual" | trim_ws)"; [[ -z "$manual" ]] && { print -u2 "No domains provided."; exit 1; }
      IFS=' ' read -A domains <<< "$manual"
    else
      IFS=$'\n' read -A chosen <<< "$sel"; domains=("${chosen[@]}")
    fi
  else
    manual=$(gum input --placeholder "No recents yet. Enter space-separated domains") || { print -u2 "No domains provided."; exit 1; }
    manual="$(print -r -- "$manual" | trim_ws)"; [[ -z "$manual" ]] && { print -u2 "No domains provided."; exit 1; }
    IFS=' ' read -A domains <<< "$manual"
  fi
else
  if [[ "${initial:l}" == "all" ]]; then
    is_all=1
  else
    IFS=' ' read -A domains <<< "$initial"
  fi
fi

if (( is_all == 1 && ${#domains[@]} > 0 )); then print -u2 "Choose ALL or specific, not both."; exit 1; fi
if (( is_all == 0 )); then
  (( ${#domains[@]} > 0 )) || { print -u2 "No domains provided."; exit 1; }
  for d in "${domains[@]}"; do is_valid_domain "$d" || { print -u2 "Invalid domain: $d"; exit 1; }; done
fi

if (( is_all == 1 )); then
  #morning captcha before any wait/confirm
  #if is_before_10am; then
  #  require_all_captcha 20 || { sudo chflags uchg "$HOSTS" 2>/dev/null || true; exit 1; }
  #fi

  w=$((30 + RANDOM % 61)); gum spin --title "Preparing ALL… waiting ${w}s" -- sleep "$w"
  confirm_window_press_enter 10 || { print -u2 "Timed out. Aborting."; sudo chflags uchg "$HOSTS" 2>/dev/null || true; exit 1; }
else
  w="$(scaled_wait_specific "$DUR")"; wait_random_secs "$w"
fi

if (( is_all == 1 )); then
  comment_all_block_lines || { sudo chflags uchg "$HOSTS" 2>/dev/null || true; exit 1; }
else
  comment_lines_containing_domains "${domains[@]}" || { sudo chflags uchg "$HOSTS" 2>/dev/null || true; exit 1; }
fi

flush_dns

if (( is_all == 1 )); then
  log_event "$DUR" "$REASON"
else
  log_event "$DUR" "$REASON" "${(j:, :)domains}"
  update_recents "${domains[@]}"
fi

schedule_reblock "$DUR"
sudo chflags uchg "$HOSTS" 2>/dev/null || true
gum style --foreground 46 "Done: $([[ $is_all -eq 1 ]] && echo ALL || echo "${(j:, :)domains}") for ${DUR}m"
